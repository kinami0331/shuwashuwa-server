<!doctype html>
<html class='blink-to-pdf' >
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>hw06_1800012926_何润之</title><link rel='stylesheet' href='file:///C:/Program%20Files/Typora/resources/app/lib.asar/diagram/css/mermaid.css' type='text/css' /><link rel='stylesheet' href='file:///C:/Program%20Files/Typora/resources/app//style/base.css' type='text/css' /><link rel='stylesheet' href='file:///C:/Program%20Files/Typora/resources/app//style/codemirror.css' type='text/css' /><link rel='stylesheet' href='file://C:\\\\Users\\\\hrz\\\\AppData\\\\Roaming\\\\Typora\\themes\\github.css' type='text/css' />
<link rel='stylesheet' href='file://C:\\\\Users\\\\hrz\\\\AppData\\\\Roaming\\\\Typora\\themes\\base.user.css' type='text/css' />
<link rel='stylesheet' href='file://C:\\\\Users\\\\hrz\\\\AppData\\\\Roaming\\\\Typora\\themes\\github.user.css' type='text/css' />
<style type='text/css'>html {overflow-x: initial !important;}
</style>
</head>
<body class='typora-export os-windows'>
<div id='write' style='top:auto' class='is-node'><p><strong><span>1. </span></strong><span> 阅读Three Easy Pieces的15.1-15.3，概括总结主要思想</span></p><p><strong><span>15.1</span></strong></p><p><span>在之前阐释CPU虚拟化时，我们提到了操作系统给了每个进程自己独占整个CPU的错觉。对于虚拟内存而言亦是如此，我们同样给每一个进程自己独占整个虚拟内存空间的错觉。这对于程序员来说是天大的好事，因为我们不可能指望他们在编写程序时考虑到所有计算机的内存大小，更不可能考虑到实际运行时其他程序对内存的占用情况。然而，怎么将程序中定义的内存地址转化为实际传输到内存地址线的信号，是操作系统设计者需要考虑的一个较为棘手的问题。</span></p><p><strong><span>15.2</span></strong></p><p><span>15.2节描述了一个非常简陋，但是能工作的解决方案。我们将用户进程的地址空间连续地存放在物理内存的某个区域，当用户进程访问内存时，我们将地址加上一个偏移量。书中给出了一个例子，某个程序的虚拟内存地址空间大小是16KB，在这个进程开始运行时，操作系统钦定物理内存地址的32KB-48KB分配给这个进程。</span></p><p><span>然而这个方案的问题是显而易见的：</span></p><ol><li><span>分配了整个内存地址空间，而程序在绝大多数情况下都不会将整个内存地址空间使用完，这造成了内碎片。</span></li><li><span>要求虚拟地址空间的大小固定，且显著小于物理内存。</span></li><li><span>重定位过程无法做到快速与完全透明，并且错误的地址可能导致当前进程修改其他进程的内存数据。</span></li></ol><p><strong><span>15.3</span></strong></p><p><span>在20世纪50年代，时分机器的设计者想到，也许硬件能为地址转换机制提供支持。</span></p><p><span>在每个CPU中，我们加入了base和bound寄存器，分别用来存储当前进程的地址空间基址和大小。在编写程序时，我们默认地址空间从0开始。在进程尝试访问内存时，硬件会将虚拟地址加上一个固定的偏移量（base寄存器的值）。于此同时，如果进程尝试访问虚拟地址空间之外的值，硬件会检查bound寄存器并抛出异常，从而保证内存访问的安全性。</span></p><p><span>由于内存地址的重定位是在运行时发生的，并且我们甚至可以动态更改内存地址的偏移量和地址空间的大小，因此这一技术被称为动态重定位。时分机器为实现动态重定位引入了硬件内存管理单元，在之后的计算机中我们将这一单元称作MMU。</span></p><p><strong><span>2.</span></strong><span>  总结交换技术的主要思想</span></p><p><span>计算机在实际的运行过程中时常会出现内存不足的情况。计算机因为内存不足而停止工作显然不是我们所希望的，因此我们需要把某些暂时不用的内存数据（例如处于阻塞态的进程的内存数据）换出到外存，把就绪状态的进程的内存数据换入内存。</span></p><p><span>覆盖技术是早期一个有效的实践——不少程序之间不存在调用关系，那我们就可以让这些程序的内存数据互相替代，将被替代的数据存入外存。然而这一机制对程序员来说并不友好，每一个程序必须拆分为多个内存占用量不大的小模块，并且显式声明模块的依赖关系。</span></p><p><span>交换技术则不存在这一问题。在换入换出时，我们可以交换整个进程的内存数据，不过整个进程的内存占用量大，换入换出较为低效。一种更为理想的方法是，我们用段或页的形式组织内存地址空间，并以段或页为单位进行换入换出。</span></p><p><span>从内存中被换出的数据会存储到交换空间，在Linux中，这一空间往往叫做swap分区或swapfile。一般来说这一空间在外存中是连续的，以保证换入换出的速度。</span></p><p><span>系统可以选择主动将不用的内存数据换出外存，或是只有当内存不够用时在将内存数据换出外存。在Linux中，我们可以通过修改vm.swapiness来改变内存交换的策略。</span></p><p><span>我们以整体交换为例，说明一种交换的策略：</span></p><p><span>当系统开始换出时，它会选择处于阻塞态且优先级最低的进程换出。然后这个进程的数据和程序区域会被复制到交换空间中。如果复制过程成功，则该进程占用的内存地址空间会被释放，其在PCB中的状态也会被修改。</span></p><p><span>系统定时查看所有进程的PCB，选择处在就绪态且被换出时间最长的进程换入，直到没有可以被换入的进程为止。</span></p><p><span>在使用了交换机制后，所有进程能够占用的内存大小从之前的物理内存大小变为物理内存大小+交换空间大小。需要注意到，采用物理地址与I/O设备通信的进程不应被换出，因为换入-&gt;换出后进程虚拟地址映射到的物理地址很可能会改变。</span></p></div>
<script> window.setBreakPage = function(b){var node = document.querySelectorAll('[data-breakpage]'); for(var i=0;i<node.length;i++){node[i].style.pageBreakBefore = b ? 'always':'auto' } return node[0] && node[0].style.pageBreakBefore};</script><script>(function(){for(var e=document.querySelectorAll("figure>table"),t=0;t<e.length;t++){var n=e[t],i=n.parentElement,r=i.scrollWidth,o=i.offsetWidth;r>o&&r>50&&(n.style.zoom=o/r,i.style.overflowX="visible")}})();</script></body>
</html>